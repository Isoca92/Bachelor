%
% Realisierung
%
\section{Realisierung} \label{realisierung}
Das Programm \textit{SmartsSmarts} wurde, wie in Kapitel \ref{ssec:struktur} beschrieben, in sechs Schritten realisiert. Im folgenden Kapitel sollen diese Schritte erläutert werden.

Grundlage des Programms zum Vergleich von chemischen Mustern sind die in Kapitel \ref{sssec:smarts} vorgestellten SMARTS-Ausdrücke.
Dem Programm werden neben einem Anfrage-SMARTS und Ziel-SMARTS zudem die zu untersuchende Teilmengen-Relation übergeben. Anschließend werden die folgenden Schritte durchgeführt.

\subsection{Aufarbeitung und Auswahl}\label{ssec:vorverarbeitung}
Der Anfrage- und Ziel-SMARTS wird zunächst in eine Form gebracht, die es ermöglicht im letzten Schritt des Verfahrens das \textit{Mapping} zu erzeugen. Die dazu genutzten \textit{Label} sind eindeutige Identifikationsnummern, die als \texttt{:ID} an die Knoten eines SMARTS-Ausdrucks gefügt werden können. Dabei wird jedes Label einmalig an das Vergleichspaar aus Anfrage- und Ziel-SMARTS vergeben. Bestehende \textit{Label} bleiben bestehen.\\
Anschließend werden für Anfrage- und Ziel-SMARTS überprüft, ob ein Vergleich grund-\\sätzlich anhand der Knoten-Anzahl und der gegebenen Relation der Muster möglich ist (siehe Tabelle \ref{tab:anzahlcheck}). Für die Schnitt-Relation ($\cap$) ist zu beachten, dass Anfrage- und Ziel-SMARTS die gleiche Anzahl an Knoten haben müssen, damit ein nicht leerer Schnitt vorliegt. Grund dafür ist, dass die Schnitt-Menge zweier SMARTS-Muster ein SMARTS-Ausdruck beschreiben, welcher eine Untermenge von Anfrage- und Ziel-SMARTS sein soll. Wären die beiden Muster unterschiedlich groß, wäre der nicht leere Schnitt maximal so groß wie der kleinere SMARTS-Ausdruck. Für das größere Muster kann also keine Untermengen-Relation vorliegen.\\

\begin{table}[h]
	\centering
	\captionabove{Anzahlüberprüfung der Knoten von Anfrage-SMARTS ($Query$) und Ziel-SMARTS ($Target$)}
	\begin{tabular}{| c | l |}
		\hline Relation & Bedingung \\
		\hline $=$ & $QueryNodeCount = TargetNodeCount$ \\
		$\subseteq$ & $QueryNodeCount >= TargetNodeCount$ \\
		$\supseteq$ & $QueryNodeCount <= TargetNodeCount$ \\
		$\cap$ & $QueryNodeCount = TargetNodeCount$ \\
		\hline
	\end{tabular}
	\label{tab:anzahlcheck}
\end{table}

\newpage
\subsection{Fingerprintgenerierung}
Die Basis für die Untersuchung auf eine bestimmte Teilmengen-Relation wird in diesem Schritt gewonnen. Anhand der Fingerprints von Knoten und Kanten können zwei chemische Muster miteinander verglichen werden.
In Kapitel \ref{sssec:valenz} und \ref{sssec:fprint} wurde bereits das Konzept des Fingerprints beschrieben.
Beide SMARTS-Ausdrücke werden in eine digitale Graphenstruktur übertragen. Über diesen Graphen wird anschließend iteriert um für jeden Knoten und jede Kante den Fingerprint zu erstellen.\\
Für Knoten werden, wie Tabelle \ref{tab:smartvalenz} zeigt, Eigenschaften ausgelesen und anhand dieser der Fingerprint generiert.\\

\begin{table}[h]
	\centering
	\captionabove{Eigenschaften der Valenzzustände für Atome und ihre zugehörigen SMARTS-Atomprimitive}
	\begin{tabular}{| l | l |}
		\hline Eigenschaft & abgeleitet aus SMARTS-Atomprimitiv \\
		\hline Element & \texttt{*}, \texttt{a}, \texttt{A} und alle Elementnamen \\
		Atomnummer & \texttt{\#n} \\
		Atomgewicht & \texttt{<n>} \\
		Atomvalenz & \texttt{v<n>} \\
		Anzahl der Einfachbindungen & \texttt{D<n>}, \texttt{H<n>} \\
		Anzahl der Doppelbindungen & \texttt{D<n>} \\
		Anzahl der Dreifachbindungen & \texttt{D<n>} \\
		Formalladung & \texttt{+<n>}, \texttt{-<n>} \\
		Anzahl zu Wasserstoffatomen & \texttt{D<n>}, \texttt{H<n>} \\
		ob das Atom aromatisch ist & \texttt{*}, \texttt{a}, \texttt{A} und alle Atomnamen \\
		in wie vielen Ringen eines SSSR & \texttt{R<n>} \\
		sich das Atom befindet  & \\
		welche Größe hat der kleinsten SSSR- & \texttt{r<n>} \\
		Ring in dem sich das Atom befindet & \\
		Anzahl der Bindungen in Ringen & \texttt{x<n>} \\
		\hline
	\end{tabular}
	\label{tab:smartvalenz}
\end{table}

Die Generierung erfolgt durch eine sequentielle Abfrage und Abgleich aller Eigenschaften und dementsprechender Bit-Setzung. Ausgegangen wird von einem Bit-Array bei dem jedes Bit auf "`1"' gesetzt ist. Im ersten Schritt werden, wie im Algorithmus \ref{alg:fingerprint1} beschrieben, die Bits, der Valenzzustände, die nicht durch die Atomnamen-Eigenschaften des Knotens beschrieben sind auf "`0"' gesetzt. Zudem wird in diesem schritt bereits die Aromazität für später untersucht.

\begin{algorithm}[H]
\caption{Fingerprintgenerierung Teil 1 \cite{Master}} \label{alg:fingerprint1}
\begin{algorithmic}[1]
\Procedure{TakePropertyFingerprint}{$node$}

\State $node\_is\_aliphatic =$ \texttt{true}
\State $node\_is\_aromatic =$ \texttt{true}
\ForAll{$\big(node\_Symbol = \Call{GetNodesSymbol}{node}\big)$} \Comment Abbildung Atomname
		
	\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
		\State $temp\_bit\_array[i] =$ \texttt{false}
	\EndFor
	
	\NoThen	
	\If{$\big(node\_symbol \ne SMARTS\_ANY\_ATOM\big)$}
		\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
			\If{$\big(node\_symbol = \Call{GetSymbol}{valencestates[i]}\big)$}
				\State $temp\_bit\_array[i] =$ \texttt{true}
			\EndIf
			\NoThen
		\EndFor

	\NoThen
		
	\If{$\big(\Call{NodeSymbolNegationFlag}{node} == \texttt{true}\big)$}
		\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
			\If{\big($temp\_bit\_array[i] ==$ \texttt{true}$\big)$}
				\State $temp\_bit\_array[i] = $\texttt{false}
			\Else
				\State $temp\_bit\_array[i] = $\texttt{true}
			\EndIf
			\NoThen
		\EndFor
    \EndIf
	\Else
	    \ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
	    \State $temp\_bit\_array[i] =$ \texttt{true}
	    \EndFor

		\If{$\big(\Call{NodeSymbolNegationFlag}{node} == \texttt{true}\big)$}
			\If{$\big(\Call{NodeIsAliphatic}{node} == \Call{NodeIsAromatic}{node}\big)$}
				\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
					\State $temp\_bit\_array[i] =$ \texttt{false}
				\EndFor
			\EndIf
			\NoThen
			\If{$\big(\Call{NodeIsAliphatic}{node} == \texttt{true}\big)$}
				\If{$\big(\Call{NodeSymbolNegationFlag}{node} == \texttt{false}\big)$}
					\State $node\_is\_aliphatic =$ \texttt{true}
				\EndIf
				\NoThen
			\Else 
				\State $node\_is\_aliphatic =$ \texttt{false}
			\EndIf
			\NoThen
			\If{$\big(\Call{NodeIsAromatic}{node} == \texttt{true}\big)$}
				\If{$\big(\Call{NodeSymbolNegationFlag}{node} == \texttt{false}\big)$}
					\State $node\_is\_aliphatic =$ \texttt{true}
				\EndIf
				\NoThen
			\Else 
				\State $node\_is\_aromatic =$ \texttt{false}
			\EndIf
			\NoThen
		\EndIf
		\NoThen
	\EndIf
	\NoThen
	\State $sec\_temp\_bit\_array = temp\_bit\_array \land sec\_temp\_bit\_array$
\EndFor
\State $bit\_array = bit\_array \lor sec\_temp\_bit\_array$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Die meisten Eigenschaften können anschließend durch einen Abgleich von Graphen-Eigen-\\schaften und Valenzzuständen im Bit Array weiter geprüft werden und gegebenenfalls weitere Bits auf "0" gesetzt werden.
Im Algorithmus \ref{alg:fingerprint2} und Algorithmus \ref{alg:fingerprint3} sind die Verarbeitung der Eigenschaften der Bindungen (\texttt{D<n>}) und der Aromazität beschrieben, da diese nicht direkt aus der Graphenstruktur abzulesen sind.

\begin{algorithm}[H]
\caption{Fingerprintgenerierung Teil 2 \cite{Master}} \label{alg:fingerprint2}
\begin{algorithmic}[1]
	\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
		\State $temp\_bit\_array[i] =$ \texttt{false}
	\EndFor
	
	\ForAll{$\big(node\_degree = \Call{GetNodesDegree}{node}\big)$} \Comment Abbildung \texttt{D<n>}
		\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$}
			\NoThen
			\If {$ \begin{pmatrix*}[l]
					&\Big(node\_degree \ne \big(\Call{GetNofBonds}{valencestates[i]}\\
					
					&-\Call{GetNofHydrogens}{valencestates[i]}\big) \textbf{ and}\\
					
					&\big(\Call{NodeDegreeNegationFlag}{node} == \texttt{false}\big)\Big)\\
					
					\textbf{or} & \Big(node\_degree = \big(\Call{GetNofBonds}{valencestates[i]}\\ 
					
					&-\Call{GetNofHydrogens}{valencestates[i]}\big) \textbf{ and}\\
					
					& (\Call{NodeDegreeNegationFlag}{node} == \texttt{true})\Big)\\
					
					\textbf{and} & bit\_array[i] == \texttt{true}
				\end{pmatrix*} $}
					\State $bit\_array[i] =$ \texttt{false}
			\EndIf
		\EndFor
		\State $temp\_bit\_array = temp\_bit\_array \lor bit\_array$
	\EndFor
	\State $bit\_array = bit\_array \land temp\_bit\_array$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Fingerprintgenerierung Teil 3 \cite{Master}} \label{alg:fingerprint3}
	\begin{algorithmic}[1]
		\ForAll{$\big(i \in [1,nof\_valenceStates]\big)$} \Comment{Abbildung Aromazität}
		\NoThen
		\If {$ \begin{pmatrix*}[l]
			& \big(node\_is\_aromatic == \texttt{true} \textbf{ and } node\_is\_aliphatic == \texttt{false}\\
			
		  	& \textbf{and } \Call{IsAromatic}{valencestates[i]} == \texttt{false}\big)\\
		  	
		  	\textbf{or} & \big(node\_is\_aromatic == \texttt{false} \textbf{ and } node\_is\_aliphatic == \texttt{true}\\
		  	
		  	& \textbf{and } \Call{IsAromatic}{valencestates[i]} == \texttt{true}\big)\\
			
			\textbf{and} & bit\_array[i] == \texttt{true} 
			\end{pmatrix*}$}
		\State $bit\_array[i] =$ \texttt{false}
		\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}

Für die Kanten wird der Fingerprint wie in Tabelle \ref{tab:smartsbind} beschrieben generiert, wobei alle eigenschaften direkt aus der Graphenstruktur abzulesen sind.\\

\begin{table}[h]
	\centering
	\captionabove{Eigenschaften zur Generierung des Fingerprints einer Bindung und dazugehörige Bindungsprimitive}
	\begin{tabular}{| l | l |}
		\hline Eigenschaft & SMARTS-Bindungsprimitive \\ 
		\hline Einfachbindung & \texttt{-}, \texttt{/}, \texttt{\char`\\}, $\sim$\\
		Doppelbindung & \texttt{=}, $\sim$\\
		Dreifachbindung & \texttt{\#}, $\sim$\\
		Ringbindung & \texttt{@}, $\sim$\\
		aromatische Bindung & \texttt{:}, $\sim$ \\ \hline
	\end{tabular}
	\label{tab:smartsbind}
\end{table}

Nicht alle Eigenschaften eines SMARTS-Ausdruck können in dem hier vorgestellten Verfahren verarbeitet werden. Zum Beispiel können die in Kapitel \ref{sssec:smarts} beschriebenen Rekursionen, die für SMARTS-Ausdrücke genutzt werden, um Umgebungen von SMARTS-Primitiven zu definieren nicht beachtet werden. Weitere nicht unterstützte\\ SMARTS-Primitve sind im Kapitel \ref{ssec:probleme}. Lösungsansätze werden in Kapitel \ref{sec:ausblick} beschrieben.

\subsection{Vergleich und Aufbau Relation-Matrix}\label{ssec:relmatr}
Für die Untersuchung auf einen Subgraphisomorphismus von zwei chemischen Mustern benötigt man Initial-Matrizen für Knoten und Kanten, die die möglichen bijektiven Abbildungen der einzelnen Elemente repräsentieren.
Anschließend wird die Initial-Matrix der Knoten und die der Kanten zusammen mit den Adjazenzmatrizen\footnote[1]{Matrix zugehörig zu einen Graphen, die durch "`1"' angeben, dass eine Kante zwischen zwei Knoten besteht oder durch "`0"', dass es keine Kante zwischen zwei Knoten gibt. Dabei besitzt sie für jeden Knoten eine Zeile ($i$) und eine Spalte ($j$). Ein Element ($i,j$) gibt die Adjazenz vom $i$ten und $j$ten Knoten an \cite{graph}} der beiden chemischen Mustern an einen Algorithmus zur Berechnung des Isomorphismus übergeben. In dieser Arbeit wurde dazu der Algorithmus nach Ullmann \cite{ullmann} verwendet.

Anhand der Fingerprints, die für alle Bestandteile der beiden zu untersuchenden SMARTS-Ausdrücke erstellt wurden, können Rückschlüsse auf die Teilmengen-Relationen gezogen werden.\\
Für den Vergleich werden einfache Bit-Operationen genutzt. Die Tabelle \ref{tab:bitop} zeigt welche Bit-Operationen dazu ausgeführt werden müssen, um die Teilmengen-Relationen zu überprüfen. Anschließend können mit den Ergebnissen der Vergleiche die Initial-Matrizen initialisiert werden. In diesem Kontext werden sie als Relations-Matrizen bezeichnet, da sie Rückschlüsse auf Teilmengen-Relationen geben.\\

\begin{table}[h]
	\centering
	\captionabove{Ergibt die durchgeführte Bit-Operation aus der linken Spalte ein Bit-Array, welches keine auf "1" gesetzten Bits enthält, so gilt die in der rechten Spalte angegebene Teilmengen-Relation \cite{Master}}
	\begin{tabular}{| l | l |}
		\hline Bit-Operation & Teilmengen-Relation \\
		\hline $QueryArray \oplus TargetArray$ & $Query=Target$ \\
		$(QueryArray \land TargetArray)\oplus QueryArray$ & $Query\subseteq Target$ \\
		$(TargetArray \land QueryArray)\oplus TargetArray$ & $Query\supseteq Target$ \\ \hline
	\end{tabular}
	\label{tab:bitop}
\end{table}

Wird für zwei Knoten oder zwei Kanten festgestellt, dass die angegebene Teilmengen-Relation besteht so wird der Matrix Eintrag auf "`1"' gesetzt. Abbildung \ref{abb:matrix} zeigt ein Beispiel einer initialisierten Relations-Matrix von zwei SMARTS-Ausdrücken.

\begin{figure}[h]
	\centering
	\begin{align*}
		\begin{pmatrix}
			0 & 1 & 1 & 1 \\
			1 & 0 & 0 & 0 \\
			1 & 1 & 1 & 1 \\
		\end{pmatrix}
	\end{align*}
	\caption{Die Matrix ist ein Beispiel einer Relations-Matrix der Teilmengen-Relation $\subseteq$, die mit dem Anfrage-SMARTS \texttt{P(=S)(S)S} und dem Ziel-SMARTS \texttt{S=P$\sim$[*,\#1]} initialisiert wurde. Die Spalten entsprechen den Knoten des Anfrage-SMARTS und die Zeilen den Knoten des Ziel-SMARTS}
	\label{abb:matrix}
\end{figure}

\newpage
Zur Überprüfung der Teilmengen-Relation $Query\cap Target$ kann keine einfache Bit-Opera-\\tion durchgeführt werden. Durch Zuhilfenahme der in Tabelle \ref{tab:bitop} beschriebenen Bit-Operationen können zwei Elemente auf $Query\cap Target$ geprüft werden. Zwei chemische Muster haben einen wie in Kapitel \ref{sssec:rel} nicht leeren Schnitt in zwei Fällen:

Sei $G^Q(V^Q,E^Q)$ die Graphenrepräsentation des Anfrage-SMARTS und $G^T(V^T,E^T)$ die Graphenrepräsentation des Ziel-SMARTS. Weiter sei ein Knoten $v \in V$ bestehend aus der Menge an logischen Alternativen $LA_v$, sowie eine Kante $e \in E$ bestehend aus der Menge an logischen Alternativen $LA_e$ dann muss für ein mögliches \textit{Mapping} gelten:
\begin{align}
\begin{split}
	& \Big[ \exists v_Q \in V^Q \exists v_T \in V^T \Big( (\exists a_Q \in LA_{v_Q} \exists a_T \in LA_{v_T} \big( a_Q =,\subseteq,\supseteq a_T \big)\\	
	& \land  \exists a'_Q \in LA_{v^Q} \neq a_Q \exists a'_T \in LA_{v^T} \neq a_T \big( a_Q' \neq a_T' \big) \Big)\\	
	& \land \forall v_Q' \in V^Q \forall v_T' \in V^T \Big(  v'_Q \neq v_Q \land v'_T \neq v_T \land v_Q' =, \subseteq, \supseteq v_T' \Big)\Big]\\	
	\lor & \Big[ \exists e_Q \in E^Q \exists e_T \in E^T \Big( (\exists a_Q \in LA_{e_Q} \exists a_T \in LA_{e_T} \big( a_Q =,\subseteq,\supseteq a_T \big)\\	
	& \land  \exists a'_Q \in LA_{e^Q} \neq a_Q \exists a'_T \in LA_{e^T} \neq a_T \big( a_Q' \neq a_T' \big) \Big)\\	
	& \land \forall e_Q' \in E^Q \forall e_T' \in E^T \Big(  e'_Q \neq e_Q \land e'_T \neq e_T \land e_Q' =, \subseteq, \supseteq e_T' \Big)\Big]\\
	\label{eq:fall1} 
\end{split}
\end{align} 

oder

\begin{align}
\begin{split}
	&\Big( \big( \exists v_Q \in V^Q \exists v_T \in V^T ( v^Q \subset v^T ) \land \exists v'_Q \in V^Q \exists v'_T \in V^T (v'_Q \neq v_Q \land v'_T \neq v_T \land v'^Q \supset v'^T) \big)\\
	& \lor \big( \exists e_Q \in E^Q \exists e_T \in E^T ( e^Q \subset e^T ) \land \exists e'_Q \in E^Q \exists e'_T \in E^T (e'_Q \neq e_Q \land e'_T \neq e_T \land e'^Q \supset e'^T) \big) \Big)\\
	\land & \forall v''_Q \in V^Q \forall v''_T \in V^T \big( v''_Q \neq v'_Q \neq v_Q \land v''_T \neq v'_T \neq v_T \land v''^Q =,\subseteq,\supseteq v''^T \big) \\
	\land & \forall e''_Q \in E^Q \forall e''_T \in E^T \big( e''_Q \neq e'_Q \neq e_Q \land e''_T \neq e'_T \neq e_T \land e''^Q =,\subseteq,\supseteq e''^T \big) \\
	\end{split}
	\label{eq:fall2} 
\end{align}

Beispiel \ref{bsp:intersecone} zeigt, zwei SMARTS-Ausdrücke bei denen für jeweils den ersten Knoten Formel \eqref{eq:fall1} gilt. Für alle weiteren Knoten und Kanten muss dann einheitlich $\subseteq, \supseteq oder =$ gelten.\\

\begin{bsp}
	\label{bsp:intersecone}
\end{bsp}
\begin{table}[h]
	\centering
	\begin{tabular}{l | c c c}
		Anfrage-SMARTS & \texttt{[Cl,I]} & $\sim$ & \texttt{O} \\
		Teilmengen-Relation & $\cap$ & $=$ & $=$ \\
		Ziel-SMARTS & \texttt{[Cl,F] }& $\sim$ & \texttt{O}\\
	\end{tabular}
\end{table}

Beispiel \ref{bsp:intersectwo} zeigt, zwei SMARTS-Ausdrücke bei denen Formel \eqref{eq:fall2} gilt. Für mindestens einen Knoten gilt $\supseteq$, in diesem Beispiel ist es jeweils der letzte Knoten. Des weiteren gilt für mindestens ein Knoten- oder Bindungspaar $\subseteq$, in diesem Beispiel die jeweils ersten beiden Knoten und die Bindung.\\

\begin{bsp}
\label{bsp:intersectwo}
\end{bsp}
\begin{table}[h]
	\centering
	\begin{tabular}{l | c c c}
		Anfrage-SMARTS & \texttt{[C;!R]} & \texttt{=} & \texttt{O} \\
		Teilmengen-Relation & $\subset$ & $\subset$ & $\supset$ \\
		Ziel-SMARTS & \texttt{[\#6] }& $\sim$ & \texttt{[OH]}\\
	\end{tabular}
\end{table}

\subsection{Subgraphisomorphie Analyse}
Anhand der im eben beschriebenen generierten Relations-Matrizen von Knoten und Kanten ist es nun möglich zwei Muster auf eine Subgraphisomorphismus zu untersuchen.

Mit der für die Knoten erzeugten Relations-Matrix, den jeweiligen Adjazenz-Matrizen und der Information zur Vereinbarkeit der Kanten durch die entsprechende Relations-Matrix wird durch den Algorithmus nach Ullmann ein Isomorphismus gesucht und die gefundenen bijektiven Abbildungen in Form von Permutationsmatrizen ausgegeben.

\subsection{Kennzeichnung}
Zur eindeutigen Zuordnung der gefundenen Isomorphismen wurde anschließend eine Än-\\derung der \textit{Label} des Ziel-SMARTS erzeugt, die als Abbildung des Anfrage-SMARTS dienen. Durch diese Kennzeichnung der Knoten eines Anfrage-SMARTS in einem Ziel-SMARTS wird bei der Ausgabe deutlich welche Knoten eine Abbildung darstellen. Beispiel \ref{bsp:labelmapping} zeigt für die vier möglichen Teilmengen-Relationen die Ausgabe der gefundenen \textit{Mappings}.\\

\begin{bsp}
	\label{bsp:labelmapping}
\end{bsp}
\begin{table}[h]
	\begin{tabular}{l l | l}
		\textbf{Gleichheit:} & Anfrage-SMARTS & \texttt{[C:1](=[O:2])[Cl,Br,I,F:3]}\\
		& Ziel-SMARTS & \texttt{[O:2]=[C:1]-[F,Cl,Br,I:3]}\\
		&&\\
		\textbf{Schnitt:} & Anfrage-SMARTS & \texttt{[\#7:1]-[N:2]=[O:3]}\\
		& Ziel-SMARTS & \texttt{[!\#7:3]$\sim$[NX2:2]$\sim$[NX1:1]}\\
		&&\\
		\textbf{Untermenge:} & Anfrage-SMARTS & \texttt{[O:1]=[C:2][N:3]=[N+:4]=[N-:5]}\\
		& Ziel-SMARTS & \texttt{[N:3]=[N+:4]=[N-:5]}\\
		&&\\
		\textbf{Obermenge:} & Anfrage-SMARTS & \texttt{[S:1][C:2]\#[N:3]}\\
		& Ziel-SMARTS & \texttt{[S:1](=[O:5])(=[O:6])[C:2]\#[N:3]}\\
	\end{tabular}
\end{table}	
%
% EOF
%