%\chapter{Anhang}

\section{Software User Guide} \label{userguide}

\subsection{Command Line Syntax} 

Command Line Syntax beginnt immer mit dem Command Line Programmnamen. Dem Programmnamen können dann Optionen und Dateinamen folgen. Die Optionen können in beliebiger Reihenfolge, angeführt von einem Minus und getrennt mit einem Leerzeichen, angegeben werden.\\

Das folgende Beispiel zeigt die Command Line Syntax, um \textit{SmartsSmarts} mit einer SMARTS Datei auszuführen:
\begin{itemize}
	\item
	\begin{itemize}
		\item Richtig: \textbf{\texttt{SmartsSmarts -t  /home/targetSMARTS.txt}}
		\item Falsch: \textbf{\texttt{SmartsSmarts -t/home/targetSMARTS.txt}}
	\end{itemize}
	\item Es müssen immer korrekte Dateiendungen mit angegeben werden (z.B.  \texttt{.txt})
\end{itemize}

\subsection{Command Line Options}

Die folgenden Optionen sind in dem \texttt{SmartsSmarts}-Programm beinhaltet:
\begin{itemize}
	\item \texttt{-h} (Hilfe)
	\item \texttt{-s} (Anfrage-SMARTS Input (String))
	\item \texttt{-l} (Anfrage-SMARTS Input (Datei))
	\item \texttt{-t} (Ziel-SMARTS Input)
	\item \texttt{-r} (Teilmengen-Relation)
	\item \texttt{-v} (Validierung (Entwickleroption))
\end{itemize}

\subsubsection*{-h (Hilfe)}
Wenn der Programmname mit dieser Option aufgerufen wird, wird eine Meldung angezeigt, die alle Optionen, exklusive der Entwickleroptionen, zusammen mit ihren benötigten Parametern, ihren Datentypen sowie ihren Beschreibungen für das Programm auflistet.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm} \textbf{\texttt{-h}}\\
\noindent \hspace*{10mm}\textbf{\texttt{--help}}

\subsubsection*{-s (Anfrage-SMARTS Input (String))}
Wenn der Programmname mit dieser Option eingeben wird, ist als weiterer Parameter ein String erforderlich, welcher in Form eines SMARTS vorliegt.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm}\textbf{\texttt{-s }}\textit{"querySMARTS"}\\
\noindent \hspace*{10mm}\textbf{\texttt{--querystring }}\textit{"querySMARTS"}\\

\subsubsection*{-l (Anfrage-SMARTS Input (Datei))}
Wenn der Programmname mit dieser Option eingeben wird, ist als weiterer Parameter ein Name einer Datei erforderlich, welche SMARTS-Strings beinhaltet.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm}\textbf{\texttt{-l }}\textit{querySMARTS}\\
\noindent \hspace*{10mm}\textbf{\texttt{--querylist }}\textit{querySMARTS}\\
\\ \textbf{Hinweis:}\\
Die SMARTS Input-Datei darf pro Zeile nur einen SMARTS-String beinhalten.

\subsubsection*{-t (Ziel-SMARTS Input)}
Wenn der Programmname mit dieser Option eingeben wird, ist als weiterer Parameter ein Name einer Datei erforderlich, welche SMARTS-Strings beinhaltet.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm}\textbf{\texttt{-t }}\textit{targetSMARTS}\\
\noindent \hspace*{10mm}\textbf{\texttt{--target }}\textit{targetSMARTS}\\
\\ \textbf{Hinweis:}\\
Die SMARTS Input-Datei darf pro Zeile nur einen SMARTS-String beinhalten.

\subsubsection*{-r (Teilmengen-Relation)}
Wenn der Programmname mit dieser Option eingeben wird, ist als weiterer Parameter ein String erforderlich, welcher in Form eines vier-elementigen Bitstrings für Schnitt-Relation vorliegt.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm}\textbf{\texttt{-r }}\textit{"Bitstring"}\\
\noindent \hspace*{10mm}\textbf{\texttt{--relationship }}\textit{"Bitstring"}

\textbf{Hinweis:}\\
Der Bitstring muss folgende Syntax einhalten:
\begin{itemize}
	\setlength\itemsep{0em}\setlength\parskip{0em}
	\item Der Bitstring besteht aus 4 Zeichen
	\item Erlaubte Zeichen sind "`0"' und "`1"'
	\item Mindestens ein Zeichen muss eine "`1"' sein
	\item Dabei sind die Teilmengen-Relationen folgenden Bits zugeordnet:
	\begin{itemize}
		\setlength\itemsep{0em}\setlength\parskip{0em}
		\item 1. Bit: Gleichheit \hspace{0.5cm}(\texttt{1000})
		\item 2. Bit: Schnitt \hspace{1.04cm}(\texttt{0100})
		\item 3. Bit: Untermenge \hspace{0.168cm}(\texttt{0010})
		\item 4. Bit: Obermenge \hspace{0.29cm}(\texttt{0001})
	\end{itemize}
\end{itemize}

\subsubsection*{-v (Validierung (Entwickleroption))}
Wenn der Programmname mit dieser Option eingeben wird, ist als weiterer Parameter ein Dateiname erforderlich, welche Molekülbeschreibungen beinhaltet. Mögliche Dateiformate sind:  \texttt{.mol2}, \texttt{.pdb}, \texttt{.sdf}, \texttt{.smi}, \texttt{.smiles}\\
Die Optionen \texttt{-s} (oder \texttt{-l}), \texttt{-t} und  \texttt{-r} sind bei dieser Option erforderlich.
Es handelt sich bei dieser Option um eine Entwickleroption, mit der die Validierung des Programms ausgeführt wird.\\
\textbf{Syntax:}\\
\noindent \hspace*{10mm}\textbf{\texttt{-v }}\textit{molecules}\\
\noindent \hspace*{10mm}\textbf{\texttt{--validation}} \textit{molecules}

Beim Aufruf des Programmes müssen die Optionen \texttt{-s} (oder \texttt{-l}), \texttt{-t} und  \texttt{-r} immer mit angegeben werden.
\pagebreak
\section{Softwarearchitektur}\label{sec:softwarearch}
\begin{figure}[h!]
	\centering
	\includegraphics[width=14cm]{images/software}
	\caption{Schematische Darstellung der Softwarestruktur des Programms \textit{SmartsSmarts}}
	\label{fig:softwarestruk}
\end{figure}
\vspace{3mm}

In Abbildung \ref{fig:softwarestruk} ist die Softwarestruktur des Programms \textit{SmartSmarts} (rot) schematisch dargestellt. Ausgehend von den Eingabedateien (Input) wird durch die nummerierten Pfeile der Ablauf des Programms dargestellt. Es wird gezeigt, welche Module (grün) und Klassen (orange) des Programms sich gegenseitig nutzen. Welche Module aus der NAOMI-Softwarebibliothek (blau) an welchen Stellen des \textit{SmartsSmarts} Programms genutzt werden, ist durch Hochzahlen gekennzeichnet. Im folgenden Kapitel werden die wichtigsten Module und Klassen erläutert.

\newpage
\section{Wichtige Module und Klassen}

\textbf{\large LabelMapping.hpp}
\begin{align*}
\hspace{0.3cm}\texttt{std::pair<std::string,std::string>} & \texttt{addLabels(const std::string \&smarts\_q,}\\
& \texttt{const std::string \&smarts\_t,}\\
& \texttt{const std::vector<std::vector<int>>}\\
& \qquad \texttt{existingLabels)}
\end{align*}
Diese Funktion versieht anhand von Anfrage-SMARTS, Ziel-SMARTS und einer Liste über die bestehenden \textit{Label} beide SMARTS-Ausdrücke mit \textit{Labeln} zur eindeutigen Kennzeichnung und gibt diese zurück.
\begin{align*}
	\hspace{0.3cm}\texttt{std::pair<std::string,}&\texttt{std::string> recalculateLabels(const std::string}\\
	& \texttt{ \&smarts\_q, const std::string \&smarts\_t,}\\
	& \texttt{ const std::vector<std::vector<int>>\&existingLabels,}\\
	& \texttt{ const Base::SimpleMatrix<int>\&solutions)}
\end{align*}
	Diese Funktion bekommt Anfrage-SMARTS, Ziel-SMARTS, eine Liste über die bestehenden \textit{Label} und eine Permutationsmatrix, die einen Isomorphismus repräsentiert, übergeben. Sie setzt die \textit{Label} anhand der gefundenen Lösung neu und gibt Anfrage- und Ziel-SMARTS zurück.\\

\textbf{\large SmartsSmartsUllmann.hpp}
\begin{flalign*}
\hspace{0.3cm}\texttt{std::vector<Base::SimpleMatrix<int>>} &\texttt{ getUllmannSolutions}&\\
&\qquad \texttt{(const std::string \&smarts\_q,}&\\
&\qquad \texttt{ const std::string \&smarts\_t,}&\\
&\qquad \texttt{ const std::string \&relation)}&
\end{flalign*}
Diese Funktion berechnet mit einem Anfrage-SMARTS, Ziel-SMARTS und einer Teilmengen-Relation in Form eines Bitstrings ein eindeutiges \textit{Mapping} und gibt dieses als Permutationsmatrix zurück.\\

\textbf{\large RelationMatrix.hpp}
\begin{flalign*}
\hspace{0.3cm}\texttt{Base::SimpleMatrix<int> initialiseNodeMatrix} & \texttt{(const std::string \&smarts\_q,}&\\
& \texttt{ const std::string \&smarts\_t,}&\\
& \texttt{ const std::string \&relation)}&
\end{flalign*}
Anhand von Anfrage-SMARTS, Ziel-SMARTS und Teilmengen-Relation in Form eines Bitstrings initialisiert diese Funktion eine Relationsmatrix. Ausgegeben wird die Relationsmatrix, die die Verträglichkeit der Knoten der beiden SMARTS-Ausdrücke repräsentiert.
\begin{flalign*}
\hspace{0.3cm}\texttt{SmartsMatcher::EdgeCompatibility} & \texttt{ initialiseEdgeCompatibility}&\\
& \qquad \texttt{(const std::string \&smarts\_q,}&\\
& \qquad \texttt{ const std::string \&smarts\_t,}&\\
& \qquad \texttt{ const std::string \&relation)}&
\end{flalign*}
Anhand von Anfrage-SMARTS, Ziel-SMARTS und Teilmengen-Relation in Form eines Bitstrings initialisiert diese Funktion ein \texttt{SmartsMatcher::EdgeCompatibility}. Ausgegeben wird das \texttt{EdgeCompatibility}-Objekt, welches die Verträglichkeit der Kanten der beiden SMARTS-Ausdrücke repräsentiert.\\

\textbf{\large Mapping.hpp}
\begin{flalign*}
\hspace{0.3cm}\texttt{std::string isNodeMappable} & \texttt{(const sg\_node *node\_q, const sg\_node *node\_t,}&\\
& \texttt{ const std::string \&relation)}&
\end{flalign*}
Anfrage-Knoten, Ziel-Knoten und Teilmengen-Relation in Form eines Bitstrings werden an diese Funktion übergeben, die anschließend prüft, welche Teilmengen-Relation bei zwei Knoten vorliegt, und diese als Bitstring zurückgibt.
\begin{flalign*}
\hspace{0.3cm}\texttt{std::string isEdgeMappable} & \texttt{(const sg\_edge *edge\_q, const sg\_edge *edge\_t,}&\\
& \texttt{ const std::string \&relation)}&
\end{flalign*}
Anfrage-Kante, Ziel-Kante und Teilmengen-Relation in Form eines Bitstrings werden dieser Funktion übergeben, die prüft, welche Teilmengen-Relation zwischen zwei Kanten vorliegt, und diese als Bitstring zurückgibt.\\

\textbf{\large Fingerprint.hpp}
\begin{flalign*}
& \hspace{0.3cm}\texttt{boost::dynamic\_bitset<> takePropertyFingerprint} \texttt{(const sg\_node *node)}&
\end{flalign*}
Diese Funktion generiert einen Fingerprint für einen gegebenen Knoten und gibt diesen in Form eines Bitsets aus.
\begin{flalign*}
& \hspace{0.3cm}\texttt{boost::dynamic\_bitset<> takePropertyFingerprint} \texttt{(const sg\_edge *edge)}&
\end{flalign*}
Diese Funktion generiert einen Fingerprint für eine gegebene Kante und gibt diesen in Form eines Bitsets aus.

\textbf{\large ExpandedValencestate.hpp}
\begin{flalign*}
&\hspace{0.3cm}\texttt{std::vector<ExpandedValenceState> createAllValenceStates()}&
\end{flalign*}
Erstellt eine Liste über alle möglichen Valenzzustände von Atom-SMARTS-Ausdrücken und gibt diese aus.\\
\textbf{\large SmartsSmartsValidation.hpp}
\begin{flalign*}
\hspace{0.3cm}\texttt{valPair validateSolution} & \texttt{(valPair validationOutput,}&\\
& \texttt{ MolLib::MutableMolPtrVector valMolecules,}&\\
& \texttt{ std::vector<Base::SimpleMatrix<int>> solutions,}&\\
& \texttt{ std::string relation, std::string smarts\_q,}&\\
& \texttt{ std::string smarts\_t)}&
\end{flalign*}
Fügt einem gegebenen ValidierungsOutput anhand einer Liste von Molekülen, einer Liste über gefundene \textit{Mappings}, einem Anfrage- und einem Ziel-SMARTS neue Ergebnisse der Validierung zu.

\section{Tests}\label{ssec:test}
Zur Überprüfung der Korrektheit des implementierten Verfahrens \textit{SmartsSmarts} wurden im ersten Schritt der Evaluation die Hauptfunktionen, die das Verfahren nutzt, auf korrekte Ergebnisse überprüft. Welche Testfunktionen genutzt wurden, wird in diesem Kapitel beschrieben.

\begin{description}
	\item[\texttt{fingerprint:}]\hfill \\
	Die Testfunktion prüft, ob bei der Übergabe von einem Knoten eines SMARTS-Ausdrucks ein Fingerprint generiert wurde, der die richtigen Bits gesetzt hat.
	
	\item[\texttt{mapping:}]\hfill \\
	Überprüft die Korrektheit der Funktion, bei der anhand von zwei Fingerprints und einer Teilmengen-Relation ermittelt wird, ob die gewünschte Teilmengen-Relation gefunden wurde.
	
	\item[\texttt{nodeRelationMatrix:}]\hfill \\
	Initialisiert eine Relationsmatrix und überprüft, ob diese korrekt erstellt wurde.
	
	\item[\texttt{smartsSmartsUllmann:}]\hfill \\
	Testfunktion die ermittelt, ob bei der Übergabe von zwei SMARTS-Ausdrücken und einer Teilmengen-Relation das erwartete \textit{Mapping} in Form einer Permutationsmatrix ausgegeben wird.
	
\end{description}

Durch die Testfunktionen konnten Fehler in der Fingerprintgenerierung und der Isomorphismus-Analyse durch den Algorithmus nach Ullmann identifiziert und behoben werden.

\newpage
\section{APIs}
Um das \textit{SmartsSmarts}-Programm einzubinden, müssen folgende Funktionen aufgerufen werden:

\textbf{Prototyp:}
\begin{lstlisting}
std::vector<int> extractExistingLabels(const std::string &smarts);
\end{lstlisting}
\textbf{Header:}\\
"`LabelMapping.hpp"'

\textbf{Beschreibung:}\\
Gewinnt aus einem gegebenen SMARTS-Ausdruck bestehende \textit{Label} und speichert diese in einem \texttt{std::vector}. Dieser Aufruf muss für Anfrage- und Ziel-SMARTS ausgeführt werden und in einem \texttt{std::vector<std::vector<int>>} gespeichert werden.

\textbf{Prototyp:}
\begin{lstlisting}
std::pair<std::string,std::string> addLabels(const std::string &querySmarts, const std::string &targetSmarts, const std::vector<std::vector<int>> &existingLabels);
\end{lstlisting}
\textbf{Header:}\\
"`LabelMapping.hpp"'

\textbf{Beschreibung:}\\
Fügt an alle Atome eines Anfrage- und eines Ziel-SMARTS, falls noch nicht vorhanden, \textit{Label} hinzu, sodass jedes Atom eine eindeutige Kennzeichnung hat.

\textbf{Prototyp:}
\begin{lstlisting}
std::vector<Base::SimpleMatrix<int>> getUllmannSolutions(const std::string &querySmarts,
const std::string &targetSmarts,
const std::string &relation);
\end{lstlisting}
\textbf{Header:}\\
"`SmartsSmartsUllmann.hpp"'

\textbf{Beschreibung:}\\
Prüft für einen Anfrage-, Ziel-SMARTS und eine Teilmengen-Relation, ob es einen oder mehrere Isomorphismen gibt, und gibt diesen in Form eines\\ \texttt{std::vector<Base::SimpleMatrix<int>>} zurück.
\newpage
\textbf{Prototyp:}
\begin{lstlisting}
std::pair<std::string,std::string> recalculateLabels(const std::string &querySmarts, const std::string &targetSmarts, const std::vector<std::vector<int>> &existingLabels, const Base::SimpleMatrix<int> &solutions);
\end{lstlisting}
\textbf{Header:}\\
"`LabelMapping.hpp"'

\textbf{Beschreibung:}\\
Kennzeichnet einen gefundenen Isomorphismus durch Neusetzung der \textit{Label} und gibt Anfrage- und Ziel-SMARTS als \texttt{std::pair<std::string,std::string>} zurück.

%Bitte gany am Ende belassen.
\nocite{*}

\section{Genutzte Datensätze}
Alle genutzten Datensätze finden sich auf dem Datenträger (Seite \pageref{endoffile})
\subsection*{ZINC-6k-Molekülliste}\label{ssec:zinc}
siehe \texttt{zinc\_rand\_6k.smi}
\subsection*{SMARTS Datensatz (ZBH)}\label{ssec:aasmarts}
siehe \texttt{all\_smarts\_zbh.txt}
\subsection*{SMARTS Filter (Experimente)}\label{ssec:experiments}
\textbf{Bristol-Myers Squibb HTS Deck Filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_BMS.txt}

\textbf{University of Dundee NTD Screening Library Filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_Dundee.txt}

\textbf{Glaxo Wellcome Hard Filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_Glaxo.txt}

\textbf{Inpharmatica Unwanted Fragments}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_Inpharmatica.txt} 

\textbf{Pfizer LINT filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_LINT.txt}

\textbf{NIH MLSMR Excluded Functionality Filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_MLSMR.txt}

\textbf{Pan Assay Interference Compounds Filters}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_PAINS.txt}

\textbf{SureChEMBL Data}\\
\noindent \hspace*{10mm}siehe \texttt{ChEMBL\_SureChEMBL.txt}

\section{Ergebnisse der Experimente} \label{ssec:exp}
Ergebnisse, die durch das Experiment (vgl. Kapitel \ref{sec:experimente}) der acht Filter entstanden sind. 28 Dateien mit Ergebnissen nach Ausführung des \textit{SmartsSmarts}-Programms. Siehe Datenträger (Seite \pageref{endoffile}).

\section{Implementation}
Siehe Datenträger (Seite \pageref{endoffile})

 
\label{endoffile}
%
% EOF
%